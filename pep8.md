## 目录

- [Python代码风格指南](#Python代码风格指南)
    - [介绍](#介绍)
    - [愚蠢的一致性是恐怖的](#愚蠢的一致性是恐怖的)
    - [代码排版](#代码排版)
        - [缩进](#缩进)
        - [Tab还是空格?](#Tab还是空格?)
        - [行最大长度](#行最大长度)
        - [是在双目操作符前面还是后面断行?](#是在双目操作符前面还是后面断行?)
        - [空行](#空行)
        - [源代码文件编码](#源代码文件编码)
        - [导入](#导入)
        - [模块级dunder名称](#模块级dunder名称)
    - [字符串引号](#字符串引号)
    - [表达式和语句中的空白字符](#表达式和语句中的空白字符)
        - [忌讳](#忌讳)
        - [其它建议](#其它建议)
    - [什么时候用末尾逗号](#什么时候用末尾逗号)
    - [注释](#注释)
        - [块注释](#块注释)
        - [內联注释](#內联注释)
        - [文档字符串](#文档字符串)
    - [命名规范](#命名规范)
        - [压倒一切的原则](#压倒一切的原则)
        - [描述:命名风格](#描述:命名风格)
        - [规定:命名规范](#规定:命名规范)
            - [避免的名字](#避免的名字)
            - [ASCII兼容](#ASCII兼容)
            - [包和模块名称](#包和模块名称)
            - [类名](#类名)
            - [类型变量名称](#类型变量名称)
            - [异常名称](#异常名称)
            - [全局变量名称](#全局变量名称)
            - [函数名称](#函数名称)
            - [函数和方法的参数](#函数和方法的参数)
            - [方法名称和实例名称](#方法名称和实例名称)
            - [常量](#常量)
            - [继承设计](#继承设计)
        - [公共接口和内部接口](#公共接口和内部接口)
    - [编程建议](#编程建议)
        - [函数注释](#函数注释)


# Python代码风格指南

## 介绍

这篇文档给出了包括主发布版本的标注库在内的Python编码规范.请参阅描述Python的C语
言实现部分的C代码风格指南的PEP文档[1].

这篇文档和PEP 257(docstring )都是改编自Guido的<Python格式指南>原始记录,并从
Barry的格式指南[2]中摘取一部分.

这篇指南随着时间在变化,由于语言的变化会增加一些规则,也会废弃一些规则.

许多项目拥有自己的编程格式指南,如果有冲突,项目应优先遵守自己定义的规则.

## 愚蠢的一致性是恐怖的

Guido的一个核心观点是一块代码用来读的次数要远远多于写它的次数.这个指南的目的是
为了使代码更可读,并且使代码在Python所有的各个系列中保持一致.如PEP 20所言, "可读
性很重要".

格式指南是为了保持一致性.与这格式指南的保持一致性是重要的.在项目中保持一致性是
更重要的.在一个模块或者函数中保持一致性是最重要的.

然而,要知道什么时候可以不一致--有时候风格指南的建议并不适用.当存在疑问时,采用最
好的方案.看一看其它的例子然后再决定看起来最好的.并且要毫不犹豫的去提问.

特别的是:不要最了遵循这份PEP而打断向后的兼容性.

忽略特定指南的一些合理情况:

1. 当使用该指南时会使可读性变差,即使是读代码的人习惯于遵守该PEP.
2. 为了和上下文代码保持一致也不需要遵守该指南(也许是历史原因),尽管这也是一个清
除其他人垃圾的机会.
3. 因为有问题的代码在该指南产生之前编写,并且没有其它理由去修改这些代码.
4. 当代码需要和之前的Python版本保持兼容,并且之前的老版本不支持指南建议的特性.

## 代码排版

### 缩进

用4个空格缩进

连续行需要对换行处的元素进行对齐,可以通过使用Python隐式地把在圆括号、括号和大括
号中的行连接起来进行垂直对齐，或者使用悬挂式缩进[7].当使用悬挂式缩进时需要考虑
下面几点:第一行不能有参数；使用更深的缩进以便能够更清晰地将它分辨出来是一个连续
行.

正确:

```
# 通过打开的分隔符对齐

foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# 使用更深的缩进,以便能够将其分辨出来

def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# 悬挂式缩减需要增加一个层次

foo = long_function_name(
    var_one, var_two,
    var_three, var_four)
```

错误:

```
# 不用垂直对齐时,第一行禁止有参数

foo = long_function_name(var_one, var_two,
    var_three, var_four)

# 要求更深的缩进,因为当前的缩减不明显
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)
```

对于连续行,4个空格的规则是可选的

可选:

```
# 悬挂式缩进**可以**用4个空格外的其它缩进

foo = long_function_name(
  var_one, var_two,
  var_three, var_four)
```

当if语句的条件语句部分太长需要写成多行时,需要注意这样一个组合,两个字母的关键词
(即if),加一个空格,加一个左括号,为多行条件的后续行创建了天然的4个空格.这个会和嵌
套在if语句内部的缩进部分带来视觉上的冲突,它也是天然地缩进4个空格.这份PEP没有明
确如何(或者是否)去增加这样的条件行和嵌套在if语句内部分的可见区别.这种的情况下可
以采用但不限于的选择包括:

```
# 没有额外的缩进
if (this_is_one_thing and
    that_is_another_thing):
    do_something()

# 增加一个注释,如果编辑器支持语法高亮可以提供一定的辨识度
if (this_is_one_thing and
    that_is_another_thing):
    # Since both conditions are true, we can frobnicate.
    do_something()

# 在条件语句的后续行增加额外的缩进
if (this_is_one_thing
        and that_is_another_thing):
    do_something()
```

(也请参阅下面关于是在双目操作符前面还是后面换行的讨论)

多行结构的右括号/圆括号/大括号,可以选择在列表最后一行的第一个非空白字符的下面
排成一列,如:

```
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
    )
```

也可以在多行结构的开始行的第一个字符下面排成一列,如:

```
my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    'a', 'b', 'c',
    'd', 'e', 'f',
)
```

### Tab还是空格?

空格是优先的缩进方式

在已经使用tab缩进的代码中,为了保持一致性,应该独立使用tab.

Python 3不允许tab和空格缩进混合使用.

Python 2代码中混合使用的tab和空格缩进应该专门的转换为用空格.

当用-t选项使用Python 2命令行解释器时,会发出代码不合法混合使用tab和空格的告警.当
使用-tt选项时告警会成为错误.强烈推荐这些使用选项!

### 行最大长度

限制每行最长为79个字符.

对于缺少结构限制的长文本块(文档字符串或者注释),每行的长度应该限制在72个字符.

限制使用的编辑器窗口宽度,就能同时一个挨一个地打开多个文件,并且当用代码审查工具
将两个版本排成两列时会更好的显示.

大部分工具默认的换行破坏了代码的视觉结构,使其更加难于理解.选择这些限制是为了避
免编辑器窗口宽带设置为80时带来的换行,即使是工具在换行时在最后一列做了标记.一些
基于web的工具可能都没有提供动态的换行.

一些团队强烈推荐更大的行长.如果代码专门或者主要有一个团队维护,可以在这个观点上
达成一致,将标称的行长从80增加到100个字符(实际上将最大长度增加到99个字符),注释和
文档字符串仍然在72个字符处换行.

Python的标准库要保守一些,要求限制每行最长79个字符(并且文档字符串/注释最长72).

将长行换行优先使用Python在括号,圆括号,大括号中的隐含的续行方式.通过在括号里的表
达式处换行,长行可以拆成多行.这要比使用反斜杠(\)来续行更优先.

有时反斜杠仍然合适.例如,长的,多重的with语句无法使用隐式续行,所以要选择反斜杠.

```
with open('/path/to/some/file/you/want/to/read') as file_1, \
     open('/path/to/some/file/being/written', 'w') as file_2:
    file_2.write(file_1.read())
```

(参阅之前多行的if语句的讨论,更深入的考虑with语句的多行情况下的缩进.)

另一个这样的例子是assert语句.

保证后续行合适的缩进.

### 是在双目操作符前面还是后面断行?

一直以来都是推荐在双目操作符后面断行.但是有两种情况会损失可读性:运算符是为了获
取分散在屏幕上不同列,运算符远离了它的参数并且在上一行.如此一来眼睛需要做额外的
工作,才能知道哪些项要加起来哪些要减去:

```
# 错误:操作符离参数太远了
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)
```

为了解决可读性的问题,数学家和他们的出版商遵循相反的惯例.Donald Knuth在他的
<Computers and Typesetting> 丛书中阐述了传统的规则:"尽管段落中的公式总是在
二元操作符后断行,但是显示的公式总是在之前断行"[3].

遵循数学家的传统通常会得到可读性更好的代码:

```
# 正确:很容易的关联操作符与参数
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)
```

在Python代码中,允许在二元操作符前后断行,只要与自身的惯例保持一致.新代码建议使用
Knuth的风格.

### 空行

用上下各一空行顶层函数和类定义.

类里方法定义用一个空行分隔.

用少量额外的空行来分割一系列的相关连的函数组合.在一堆相关的单句之间可以忽略空行.

在函数中用少量的空行来区分逻辑部分.

Python允许使用control-L(即^L)换页符作为空白字符;许多工具将这个字符视为换页符,
所以你可以用它们将你的文件相关的部分独立成页.注意,一些编辑器和基于web的代码阅读
器可能不能将control-L识别为换页符,会将它显示成其它的符号.

### 源代码文件编码

核心的Python发行版代码应该总是使用UTF-8(Python 2用ACSII).

文件使用ASCII（Python 2）或UTF-8（Python 3）不需要有编码声明。

在标准库中,非默认的编码格式只能为了测试目的使用,或着是当注释或文档字符串需要提
到包含非ACSII字符的作者名字时使用.否则,在字符串中包含非ASCII数据时优先使用\x,
\u,\U,或者\N这些转义字符.


对于Python 3.0及以后的版本,标准库需要遵循下面的策略(参阅PEP 3131):标准库里的所
有标识符必须使用只包含ACSII字符的标识符,并且应该在可行的情况下使用英语单词(很多
情况下,缩写和术语不是英语).另外,字符串文字和注释也必须是ACSII字符.唯一的例外是:
(a)测试非ACSII特性的特殊用例,(b)作者名字.不是拉丁字母的作者名字必须提供拉丁音译.

拥有全世界用户的开源项目也鼓励采用类似的策略.

### 导入

* 导入通常独自一行,例如:

    正确:
 
    ```
    import os
    import sys
    ```

    错误:

    ```
    import sys, os
    ```

    尽管这样也没问题:

    ```
    from subprocess import Popen, PIPE
    ```

* 导入语句总是放在文件的顶部,仅仅在模块的注释和文档字符串之后,在模块的全局变量
和常量之前.

    导入可以按下面的顺序分组:

    1. 标准库
    2. 相关的第三方库
    3. 私有应用/库

    你应该在各个组之间添加空行

* 推荐绝对路径的导入,因为这样会更加可读,并且在导入系统错误配置(例如当在包里的一
个文件夹以sys.path结尾)时倾向于表现的更好(或者至少能给出更好的错误信息):

    ```
    import mypkg.sibling
    from mypkg import sibling
    from mypkg.sibling import example
    ```

    然而,明确的相对导入是一种绝对导入的可接受的备选,特别是当处理复杂的包布局时,
    使用绝对导入会有很不必要的冗余.

    ```
    from . import sibling
    from .sibling import example
    ```
    标准库代码应该避免复杂的包布局,并且一直使用绝对引入.

    不明确的相对引用绝不能使用,并且已经从python 3中移除.

* 当从类模块导入类时,通常这样写:

    ```
    from myclass import MyClass
    from foo.bar.yourclass import YourClass
    ```

    如果这样写导致自身名称冲突,可以这样写:

    ```
    import myclass
    import foo.bar.yourclass
    ```

    这样使用"myclass.MyClass" 和 "foo.bar.yourclass.YourClass"

* 避免通配符导入,因为这样为不清楚名字是哪个命名空间的,使读者和许多自动化工具迷
惑.有一种通配符导入的防御式的使用情况,将内部的接口重发布为公共API的接口(例如,
覆盖一个可选的加速器模块里定义的接口的纯Python实现,确切地说,哪些定义将被覆盖是
事先不知道的)

    当用这种方式重新命名时,下面的指南对于公众和内部接口仍然适用.

### 模块级dunder名称

模块级"dunders"(即,两个下划线开始并且两个下划线结束的名称)如`__all__`,
`__author__`,`__version__`,等等,应放在除`from __future__`导入语句之前.Python
强制future导入必须在模块除文档字符串之外的最前面.

例如:

```
"""This is the example module.
 This module does stuff.
"""

from __future__ import barry_as_FLUFL

__all__ = ['a', 'b', 'c']
__version__ = '0.1'
__author__ = 'Cardinal Biggles'


import os
import sys
```

## 字符串引号

Python中,单引号字符串和双引号字符串是一样的.这份PEP不会作出选择.选一个规则并遵
守即可.当字符串包含单引号或双引号字符时,用另外的一个来避免使用反斜杠.这提高了可
读性.

对于三个引号的字符串,总是用双引号来和PEP 257中文本字符串规范保持一致,

## 表达式和语句中的空白字符

### 忌讳

避免下列情况的无关空白字符

* 紧接着括号,圆括号或者大括号里:

    正确:

    ```
    spam(ham[1], {eggs: 2})
    ```

    错误:

    ```
    spam( ham[ 1 ], { eggs: 2 } )
    ```

* 在尾逗号和后面的闭括号之间

    正确:

    ```
    foo = (0,)
    ```

    错误:

    ```
    bar = (0, )
    ```

* 紧接着逗号,分号,冒号之前:

    正确: 

    ```
    if x == 4: print x, y; x, y = y, x
    ```

    错误: 

    ```
    if x == 4 : print x , y ; x , y = y , x
    ```

* 然而,在分片中,冒号作为二元操作符,应该在两边都有相同数量的空白字符(将它作为最
低优先级的操作符).在延伸分片中,双冒号必须放相同数量的空白字符.例外:当一个分片参
数忽略时,空白字符也忽略.

    正确:

    ```
    ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
    ham[lower:upper], ham[lower:upper:], ham[lower::step]
    ham[lower+offset : upper+offset]
    ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
    ham[lower + offset : upper + offset]
    ```

    错误:

    ```
    ham[lower + offset:upper + offset]
    ham[1: 9], ham[1 :9], ham[1:9 :3]
    ham[lower : : upper]
    ham[ : upper]
    ```

* 紧跟在函数调用的参数列表的开括号之前:

    正确: 

    ```
    spam(1)
    ```

    错误: 

    ```
    spam (1)
    ```
 
* 紧跟在索引或者分片的开括号之前:

    正确:

    ```
    dct['key'] = lst[index]
    ```

    错误:

    ```
    dct ['key'] = lst [index]
    ```

* 等号(或者其它)前后的多个空格,为了和其它的对齐:

    正确:

    ```
    x = 1
    y = 2
    long_variable = 3
    ```

    错误:

    ```
    x             = 1
    y             = 2
    long_variable = 3
    ```

### 其它建议

* 避免任何位置的结尾添加空白字符.因为这通常不可见,会造成迷惑:例如,反斜杠后跟一
个空格,换行符不算作续行标记.一些编辑器不会保留这些空白字符,许多项目(像Cpython)
通过预提交钩子来拒绝这样的写法.

* 总是在这些二元操作符两边各加一个空格:赋值(=),增量赋值(+=,-=等等),比较(==,<,>,
!=,<>,<=,>=,in,not in,is,is not),布尔(and,or,not).

* 如果应用了不同优先级的多个操作符,考虑添加在最低优先级的操作符周围添加空白字符.
自己判断,然而绝不能超过一个空格,并且总是在二元操作符两边保证一致数量的空白字符.

    正确:

    ```
    i = i + 1
    submitted += 1
    x = x*2 - 1
    hypot2 = x*x + y*y
    c = (a+b) * (a-b)
    ```

    错误:

    ```
    i=i+1
    submitted +=1
    x = x * 2 - 1
    hypot2 = x * x + y * y
    c = (a + b) * (a - b)
    ```

* 当等号用来生命关键字参数或者参数默认值时,不要在两边添加空格,

    正确:

    ```
    def complex(real, imag=0.0):
        return magic(r=real, i=imag)
    ```

    错误:

    ```
    def complex(real, imag = 0.0):
        return magic(r = real, i = imag)
    ```

* 函数FIXME对于冒号采用通用的规则,如果存在箭头->,要在两边加上空格.

    正确:

    ```
    def munge(input: AnyStr): ...
    def munge() -> AnyStr: ...
    ```

    错误:

    ```
    def munge(input:AnyStr): ...
    def munge()->PosInt: ...
    ```

* 当给参数FIXME指定默认值时, 在 = 两边加上空格(但是只针对既有FIXME又有默认值的
参数).

    正确:

    ```
    def munge(sep: AnyStr = None): ...
    def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...
    ```

    错误:

    ```
    def munge(input: AnyStr=None): ...
    def munge(input: AnyStr, limit = 1000): ...
    ```

* 不鼓励复合语句(一行有多条语句)

    正确:

    ```
    if foo == 'blah':
        do_blah_thing()
    do_one()
    do_two()
    do_three()
    ```

    千万不要:

    ```
    if foo == 'blah': do_blah_thing()
    do_one(); do_two(); do_three()
    ```

* 有时可以在if/for/while的一行后面有一段代码,但绝不要在多分支语句这样做.也要避
免折叠长的行.

    千万不要:

    ```
    if foo == 'blah': do_blah_thing()
    for x in lst: total += x
    while t < 10: t = delay()
    ```

    绝不要:

    ```
    if foo == 'blah': do_blah_thing()
    else: do_non_blah_thing()

    try: something()
    finally: cleanup()

    do_one(); do_two(); do_three(long, argument,
                                 list, like, this)

    if foo == 'blah': one(); two(); three()
    ```

## 什么时候用末尾逗号

除了在元组的一个元素后是强制的(python2的print语句中也有语义),逗号通常都是可选的.
为了清楚起见，建议在（技术上是冗余的）括号中包围后者。

正确:

```
FILES = ('setup.cfg',)
```

可以使用,但是不够清晰:

```
FILES = 'setup.cfg',
```

当逗号冗余时,当使用版本控制系统时,当期望后续一列数值,参数或者导入的项目期望能够
扩展时,通常都是有用的.这个模式是将各个数值独自放置一行,总是要一个逗号,并且在下
一行放一个闭括号.尽管在与闭合分隔符相同的行上添加一个逗号是没有意义的(除非在上
面的例子里是单例元组).

正确:

```
FILES = [
    'setup.cfg',
    'tox.ini',
    ]
initialize(FILES,
           error=True,
           )
```

错误:

```
FILES = ['setup.cfg', 'tox.ini',]
initialize(FILES, error=True,)
```

## 注释

与代码相矛盾的注释比没有注释还糟糕.在代码修改时,始终要保证注释的更新.

注释应该用完整的语句.如果注释是一个短语或者语句,第一个字需要大写,除了它是以小写
字母开始的标识符(绝不要改变标识符的大小写).

如果注释很短,结束的句号可以忽略.块注释通常包含一段或多段完整的句子,每个句子都应
该用句号结束.

应该在每个句子结束的句号后用两个空格.

写英文时，请遵循Strunk和White。

其他不说英语的国家的Python编程者:请使用英语注释,除非你能120%的确认代码绝不会被
不说你的语言的人员阅读.

### 块注释

块注释通常用于后续的一部分(或者所有)代码,并且和代码保持相同的缩进.块注释的每一
行都以#和一个空格开始(除了在注释中缩进的文本).

块注释中的段落应该用只有#组成的行分隔.

### 內联注释

保守的使用內联注释.

內联注释是和语句在同一行的注释.內联注释应该和语句间用至少两个空格分隔开.內联注
释应该从一个#号和一个空格开始.

当內联注释只描述明显的情况是不必要的,并且是分心的.不要这样做:

```
x = x + 1                 # Increment x
```

但有时这样是有用的:

```
x = x + 1                 # Compensate for border
```

### 文档字符串

在PEP257中,一直在强调写高质量的文档字符串的约定.

* 为所有的公共的模块,函数,类,方法写文档字符串.非公共的方法不必须写文档字符串,但
是应该有描述这个方法是干什么的注释.注释应该写在def行下面.

* PEP257描述了正确的文档字符串的惯例.注意最重要的是,多行文档字符串的结束标志
`"""`应该独自一行,例如:

    ```
    """Return a foobang

    Optional plotz says to frobnicate the bizbaz first.
    """
    ```

* 一行的文档字符串应该保持闭合的`"""`在同一行.

## 命名规范

Python库的命名规范有点乱,所以我们永远不会这样完全一致 - 然而，这里是目前推荐的
命名标准.新的模块和包(包含第三方的框架)应该按照这些标准去写,但是如果有一个库是
不同的风格,更倾向于保持内部的一致性.

### 压倒一切的原则

作为APC的公共部分,用户可见的名称应该遵循反映使用而不是实现的原则.

### 描述:命名风格

有很多不同的命名风格.它有助于能够识别正在使用的命名风格，独立于它们所用的内容.

通常区分以下命名风格:

* b(一个小写字母)
* B(一个大写字母)
* 小写
* 带下划线的小写
* 大写
* 带下划线的大写
* 首字母大写的词组(或者叫驼峰式命名法--这样命名是因为字母们看起来上下颠簸[4].这
有时被叫做StudlyCaps)

    注意:当使用缩写时,需要将缩写词的所以字母都大写.因此HTTPServerError比HttpServerError要好.

* 混合大小写(和首字母大写的不同在于以小写字母开始)
* 带下划线的首字母大写(丑陋!)

也有一种风格是一组相关连的名字同时使用一个短的唯一的前缀.在Python中这样的应用不
多,但是为了完整也提出来.例如,os.stat()函数返回的元组的元素都传统命名为st_mode,
st_size, st_mtime等等.(这是为了强调和POSIX系统调用结构字段的对应,帮助程序员熟悉.)

X11库的所有公共函数都用X开头.在Python中,这样的风格是不必要的,因为属性和方法的名
称都有它的对象的前缀,而函数的名称有模块名称作为前缀.

另外,下面这些特殊的用下划线开始或者结束的格式是被认可的(这些通常可以和任意大小
写情况合并):

* 以一个下划线开始:弱的"内部使用"的标识.例如: from M import *不会导入以一个下划
线开始的名字的对象.
* 以一个下划线结束:一贯用来避免和Python的关键字的冲突,
例如:Tkinter.Toplevel(master, class_='ClassName')
* 以双下划线开始:当命名一个类的属性时,会引起名字的修改(在FooBar类中,__boo变为
`__FooBar__boo`;参看下文).
* 以双下划线开始并以双下划线结束:用户控制的命名空间的魔力对象或者属性,例如,
`__init__`,`__import__`,或者`__file__`.绝不要访问这些名字;只可以用它们记录.

### 规定:命名规范

#### 避免的名字

绝不使用字母'l'(小写字母l),'O'(大写字母o),或者'I'(大写字母i)作为唯一字符变量的
名称.

在一些字体里,这些字母无法和数字1和0分辨出来.当要使用'l'时,用'L'替代.

#### ASCII兼容

标准库使用的标识符必须是ASCII兼容的,见PEP 3131 的策略章节 .

#### 包和模块名称

模块应该用段的,全小写的名字.如果能够增强可读性,可以在模块名中使用下划线.
Python包同样应该用短的,全小写的名字,但不鼓励使用下划线.

当一个C/C++模块的有一个提供高级接口的Python模块,C/C++模块应用以下划线开始(例如:
_socket).

#### 类名

类名通常应该使用首字母大写词组的方式.

当接口已经记录并且主要用来被调用时,可以使用函数的命名规范来替代.

要注意内建的名字是有独立的规范:大部分内建的名称都是一个单词(或者两个单词连在一
起),CapWords约定仅用于异常名称和内置常量。

#### 类型变量名称

如在PEP 484介绍,类型变量应该用CapWords并越段越好:T, AnyStr, Num.建议变量增加
后缀_co或者_contra,用于相应地声明协变或逆转行为.例子:

```
from typing import TypeVar
            
VT_co = TypeVar('VT_co', covariant=True)
KT_contra = TypeVar('KT_contra', contravariant=True)
```

#### 异常名称

考虑到异常可能是类,所以用类的命名规范.尽管你的异常名字应该使用后缀"Error"(如果
异常真的是一个错误的话).

#### 全局变量名称

(让我们祈祷这些变量意味着只是一个模块内部使用.)与函数的规范大致相同.

设计成通过from M import * 来使用的模块应该用 __all__ 机制来阻止导出全局变量,或
者使用给全局变量加下划线前缀这样老的规范来确定这些全局变量是模块非公开的.

#### 函数名称

函数名称应该是小写,并用下划线来分隔单词增加可读性.

混合大小写的模式只能在已经是主流风格的上下文中使用,用来保持向后的兼容性.

#### 函数和方法的参数

总是使用self 作为实例方法的第一个参数.

总是使用cls 作为类方法的第一个参数.

如果一个函数的参数名字和一个保留的关键字冲突了,通常加一个下划线比用缩写或者拼写
错误更好.因此class_ 比 clss更好.(也许更好的是用代名词来避免冲突.)

#### 方法名称和实例名称

应用函数命名规则:小写并必要时用下划线分隔单词来增强可读性.

只有非公共的方法或者实例变量使用一个下划线开始.

为了避免和子类的名称冲突,使用两个下划线开始来触发Python的名称修改规则.

Python修改这些类名:如果一个类Foo有一个属性名字为__a,不能够通过Foo.__a访问.(坚持
要访问用Foo._Foo__a.)通常来说,只有在避免和设计为子类的类中的属性名冲突时才使用
双下划线.

注意:关于__names的使用有一些争议(加后文).

#### 常量

常量通常被定义为模块级别的,并且用全大写字母加下划线来分隔单词.例子包括
MAX_OVERFLOW 和 TOTAL.

#### 继承设计

总是定好一个类的方法或者实例变量(集合:属性)应该是公共的还是非公共的.如果存在疑
问,选择非公共;后续将它改为公共要比将一个公共属性改为非公共要简单.

公共属性是这些你期望你的类被不相关的客户使用的属性,需要你承诺避免不向后兼容的修
改.非公共属性是这些不会被第三方用户使用的属性;你不保证非公共属性不会更改甚至被
删除.

在这里我们不使用"私有"这个词,因为在Python中没有属性是真正私有的(没有不必要的工
作量).

另一个属性的分类是它们是子类 API的一部分(其它语言一般叫保护).

一些类设计上是通过继承,或修改或扩展类的某些方面的行为.当设计这样的分类时,要小心
翼翼的明确定义哪些属性是公共的,哪些是子类API的一部分,哪些是只有在你基础类里才使
用.

从这方面考虑,下面是Pythonic指南:

* 公共属性不应该以下划线开始.
* 如果你的公共属性名称和保留的关键字冲突了,在后面扩展一个下划线.这样比用缩写或
者错误拼写更推荐使用.(然而，尽管有这个规则，“cls”是作为类的任何变量或参数的首选
拼写，特别是类方法的第一个参数。)

    注意 1: 参考上面的类方法的参数名称建议.

* 对于简单的公共数据属性,最好是暴露属性名字,不要使用复杂的访问/修改方法.要记住,
如果你发现一个简单的数据属性需要扩展为函数行为时,Python提供了简单的方式.在这种
情况下,使用将函数实现隐藏在访问数据属性后的语法特性.
 
    注意1: 只有新式类才有这个特性

    注意2:尝试去保持函数行为没有副作用,即使是例如缓存等很好的副作用.

    注意3:避免对计算量昂贵的操作使用这个特性；这属性符号会使调用者认为访问会(相
          对的)"便宜".

* 如果你的类将会被子类继承,并且有不想要被子类使用的属性,请考虑以双下划线开始命
名,并且不带尾部下划线.这会引起Python的名称修改算法,类的名字会被修改到属性的名字
里.这样会有助于避免属性名字冲突,因为子类会无意中包含具有相同名称的属性.

    注意1:请注意，在修改名称只使用简单类名称，所以如果一个子类选择相同的类名称
          和属性名称，仍然会名称冲突.

    注意2:名称的修改,可能会使一些如调试和__getattr__()等功能不太方便.然而名称修
          改算法是有据可查的,并且易于手动执行.

    注意3:并不是所有人都喜欢变动.试着去平衡避免意外的名称冲突的需求和上层调用者
          的潜在使用.

### 公共接口和内部接口

只有针对公共接口才使用向后的兼容保证.于是,用户能够清晰地分辨出公共接口和内部接
口就很重要了.

记录的接口被认为是公共接口,除非文档里确切的声明它们是临时的或内部的接口,可以豁
免保证向后的兼容性.所有非记录的接口应用被设定为内部接口.

为了更好的支持内省,模块应该明确的使用__all__属性来声明公共API的名称.将__all__
设置为空意味这这个模块没有公共API.

甚至当__all__设置正确的情况下,内部接口(包,模块,类,函数,属性或其它名字)应该一直
用一个单下划线做前缀开始命名.

当一个接口包含任何被认为是内部的命名空间(包,模块或者类),那它也被认为是内部接口.

应始终将导入的名称是视为实现细节.其它模块一定不要间接访问这些导入的名称,除非它
们明确是是模块API文档描述的一部分,例如os.path或者从子模块公开功能的包的__init__
模块.

## 编程建议

* 应该以不影响Python其它实现(PyPy,Jypthon,IronPython,Cython,Psyco等等)的方式写
代码.

    例如,不要依赖CPython中a += b或者a = a + bu语句的原位置字符串连接的高效实现.
    即使在CPython中这种优化也是脆弱的(只有在一些情况下才工作),在不使用引用计数
    的情况下这种优化完全不存在.库里关心性能的部分,应该用''.join()形式替代.这能
    够保证连接在各种实现里都是线性时间.

* 比较像None这样的单字符,应该总是用is或者is not,绝不要用等于操作符.

    同样,有意识的用if x当你真的用来表示 if x is not None --- 例如,当测试一个默
    认值是None的变量或者参数是否被设置了其它值时.其它值可能是一种在布尔上下文会
    失败的类型(例如容器)

* 用is not操作符而不是not ... is.尽管两者表达式在功能上是一致的,但前者更加可读
并且更加推荐.

    正确:

    ```
    if foo is not None:
    ```

    错误:

    ```
    if not foo is None:
    ```


* 当用大量比较来实现排序操作时,最好是用所有6个操作(`__eq__`,`__ne__`, `__lt__`, 
`__le__`, `__gt__`, `__ge__`)来实现,而不是依赖于只完成特定比较的代码.

    为了最小化带来的影响,functools.total_ordering()装饰器提供了一个工具来生成遗漏的比较方法.

    PE P207展示了Python提供的反身性规则.因此,解释器可能会将y > x换为 x < y,
    y >= x换为x <= y,并且可能交换x == y和 a != y 参数.sort()和min()操作保证用
    < 操作符,max()函数用>操作符.然而,最好是执行所有的6个操作,避免在其它情况下出
    现混淆.

* 在将lambda表达式绑定一个标识符时,总要使用def语句来代替赋值语句

    正确:

    ```
    def f(x): return 2*x
    ```

    错误:

    ```
    f = lambda x: 2*x
    ```

    第一种形式意味着结果函数对象的名称是特定的'f'而不是通用的'<lambda>'.这通常
    在回溯和字符串表达时更有用.赋值语句的使用消除了lambda表达式比显式的def语句
    的唯一好处(例如:可以嵌入到一个较大的表达式的内部).

* 使用从Exception的派生异常而不是BaseException.保留从BaseException直接继承是为
了捕捉它们总是出错的异常.

    基于代码需要抓住的异常去设计异常的层次,而不是异常发生的地方.目标是回答问题
    "什么出错了?" ,而不只是说明"发生了一个问题"(参考PEP 3151中的一个例子作为学
    习内建异常层级的课程)

    在此使用类的命名规范,尽管你应该在你的异常类里给是错误的异常添加"Error"后缀.
    用于非本地流程或者其它形式的信号等不是错误的异常不需要特殊的后缀.

* 适当的使用异常链.在Python 3中,"raise X from Y"应该被用来表示明确的替换而不会
丢失原始的回溯.

    当故意更换一个内部的异常(Python 2中用"raise X"或者在Python 3.3+中用
    "raise X from None),要确保相关的细节传递到了新的异常(例如,将KeyError转换为
    AttributeError时要保留属性名称,或者,将原始的异常文本嵌入到新的异常消息里).

* Python 2中产生异常时,用raise ValueError('message')代替之前的形式
raise ValueError, 'message'.

    Python 3语法已经不支持后一种形式了.

    使用括号的方式也意味着当异常参数很长或者包含字符串格式化时,因为在括号里的
    原因不需要用续行字符.

* 当捕捉到异常时,尽可能的提及指定的异常,而不是用空白异常:从句.

    例如,使用:

    ```
    try:
        import platform_specific_module
    except ImportError:
        platform_specific_module = None
    ```

    一个空白异常:从句会捕捉SystemExit和KeyboardInterrupt异常,很难通过Control-C
    来中断一个程序,并且会掩盖其它问题.如果你想要捕捉所以告知程序错误的异常,使用
    Exception:(空白异常想BaseException:一致).

    一条很棒的规则来限制使用空白“异常”从句到两种情况:

    1. 是否异常处理会打印或记录回溯；至少使用者意识到发生了一个错误.
    2. 是否代码需要做一些清理工作,但随后让异常向上传递.这种情况下try...finally
    会是一个更好的方式.

* 当将捕捉到的异常绑定一个名称时,优先使用下面的Python 2.6中添加的名称绑定语法.

    ```
    try:
        process_data()
    except Exception as exc:
        raise DataProcessingFailedError(str(exc))
    ```

    这是Python 3唯一支持的语法,并且要避免老的基于逗号的语法相关的歧义问题.

* 当捕捉到系统错误时,优先使用Python 3.3中引入的显式异常层次结构，而不是內省的
errno值.

* 另外的,对于所有的try/except条目,将try子句限制到必需的绝对最小代码量.再次.这会
避免掩盖错误.

    正确:

    ```
    try:
        value = collection[key]
    except KeyError:
        return key_not_found(key)
    else:
        return handle_value(value)
    ```

    错误:

    ```
    try:
        # Too broad!
        return handle_value(collection[key])
    except KeyError:
        # Will also catch KeyError raised by handle_value()
        return key_not_found(key)
    ```

* 当资源只是针对特定的一段代码时,用with语句去保证在使用后及时并安全的释放.同样
可以选择try/finally语句.

* 应该通过独立的函数或方法来进行上下文管理,而不仅仅是获取释放资源.例如:

    正确:

    ```
    with conn.begin_transaction():
        do_stuff_in_transaction(conn)
    ```

    错误:

    ```
    with conn:
        do_stuff_in_transaction(conn)
    ```

    后面的例子没有提供任何信息来表明__enter__和__exit__方法正在做一些事情，而不
    是在事务之后关闭连接.在这种情况下明确是很重要的.

* return语句保持一致.一个函数的所有的return语句都应该返回一个表达式,或者都不应
该返回表达式.如果有任何return语句返回一个表达式,没有值返回的return语句应该明确
的用返回None来声明没有返回值,并且应该在函数末尾(如果能够执行到)放置一个return语
句.

    正确:

    ```
    def foo(x):
        if x >= 0:
            return math.sqrt(x)
        else:
            return None

    def bar(x):
        if x < 0:
            return None
        return math.sqrt(x)
    ```

    错误:

    ```
    def foo(x):
        if x >= 0:
            return math.sqrt(x)

    def bar(x):
        if x < 0:
            return
        return math.sqrt(x)
    ```

* 使用字符串方法而不是字符串模块.

    字符串方法总是要更快一些,并且和unicode字符串共享API.如果要求和Python 2.0之
    前的版本兼容请废除这条规则.

* 使用''.startswith()和''.endswith()来检查前缀或者后缀,而不是字符串分片.

    startswith()和endswith() 更清晰并且更少出错.例如:

    正确:

    ```
    if foo.startswith('bar'):
    ```

    错误:

    ```
    if foo[:3] == 'bar':
    ```

* 比较对象类型应该总是用isinstance(),而不是直接比较类型.

    正确:

    ```
    if isinstance(obj, int):
    ```

    错误:

    ```
    if type(obj) is type(1):
    ```

    当检查一个对象是不是字符串时,记住也有可能是一个unicode字符串!在Python 2中,
    str和unicode是同一个基类,basestring,所以你可以这样做:

    ```
    if isinstance(obj, basestring):
    ```

    注意在Python 3中,unicode和basestring都不存在了(只有str了),并且bytes对象也不
    再是一种字符串了(它修改为了整数序列).

* 对于序列,(字符串,列表,元组),使用空序列就是false的实现事实.

    正确:

    ```
    if not seq:
    if seq:
    ```

    错误:

    ```
    if len(seq):
    if not len(seq):
    ```

* 不要用依赖有意义的结尾空白字符的字符串.结尾的空白字符在视觉上不容易分辨,而且
一些编辑器(或最近，reindent.py)会裁掉它们.
* 不要用==去比较布尔值和Ture或False.

    正确:

    ```
    if greeting:
    ```

    错误:

    ```
    if greeting == True:
    ```

    更不允许:

    ```
    if greeting is True:
    ```

### 函数注释

随着PEP 484的采用,函数注释的风格规则变化了.

* 为了向前兼容,Python 3代码中的函数注释应该优先使用PEP 484语法.(在前面的章节有
一些针对注释的格式化建议.)
* 不再建议使用在这篇PEP前面建议的注释风格进行试验.
* 然而,除stdlib之外，现在鼓励使用PEP 484规则进行实验.例如,使用PEP 484风格注释标
记大量的第三方库或者应用,回顾添加这些注释是多么简单,并且观察它们的出现是否使代
码各易理解.
* Python标准库采用这样的注释应该要保守,但是允许在新代码和大的重构时使用.
* 对于想要使用不同函数注释的代码,建议在文件开始部分添加如下注释:

    ```
    # type: ignore
    ```

    这会告诉类型检查器忽略所有的注释.(在PEP 484中可以找到去掉类型检查器抱怨的更
    好方式.)

* 类似lint等检查工具,类型检查器是可选的,独立的工具.Python解释器默认情况下不应该
由于类型检查而发出任何消息，并且不应该基于注释来改变它们的行为.
* 不想使用类型检查器的用户可以很简单的忽略它们.然而,预计第三方库包的用户可能希
望在这些包上运行类型检查器.为了这个目的,PEP 484建议使用存根文件: 类型检查器使用
的.pyi文件,而不是相应的.py文件.存根文件可以和库一起发布,或者通过typeshed repo独
立发布(经过库作者的同意)[5]
* 为了保持向后兼容性的代码,类型注释可以加在注释表单里.参考PEP 484相关的章节.

脚注:

[7]	悬挂缩进是一种类型设置样式，除了第一行以外，段落中的所有行都是缩进的.在
Python的上下文中，该术语用于描述这样的一种样式，带括号的语句的左括号是该行的最
后一个非空白字符，随后的行被缩进，直到右括号结束。

参考资料:

[1]	PEP 7, Style Guide for C Code, van Rossum

[2]	Barry's GNU Mailman style guide http://barry.warsaw.us/software/STYLEGUIDE.txt

[3]	Donald Knuth's The TeXBook, pages 195 and 196.

[4]	http://www.wikipedia.com/wiki/CamelCase

[5]	Typeshed repo https://github.com/python/typeshed

[6]	Suggested syntax for Python 2.7 and straddling code 
https://www.python.org/dev/peps/pep-0484/#suggested-syntax-for-python-2-7-and-straddling-code

Copyright

This document has been placed in the public domain.

Source: https://github.com/python/peps/blob/master/pep-0008.txt

